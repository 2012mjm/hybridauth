<?php
/*!
* This file is part of the HybridAuth PHP Library (hybridauth.sourceforge.net | github.com/hybridauth/hybridauth)
*
* This branch contains work in progress toward the next HybridAuth 3 release and may be unstable.
*/

namespace Hybridauth;

/**
 * Hybrid_Auth class
 * 
 * Hybrid_Auth class provide a simple way to authenticate users via OpenID and OAuth.
 * 
 * Generally, Hybrid_Auth is the only class you should instanciate and use throughout your application.
 */
class Hybridauth
{
	protected $config  = array();

	protected $storage = null;

	// --------------------------------------------------------------------

	/**
	* Initialize HybridAuth
	*
	* http://hybridauth.sourceforge.net/userguide/Configuration.html
	*/
	function __construct( $config, \Hybridauth\Storage\StorageInterface $storage = null )
	{
		// sotre given config
		$this->config = $config;

		if( ! is_array( $this->config ) ){
			$this->config = include $this->config;
		}

		// Storage 
		$this->storage = $storage ? $storage : new \Hybridauth\Storage\Session();

		// if an error was stored on endpoint
		if( $this->storage->get( "hauth_session.error.status" ) ){
			$m = $this->storage->get( "hauth_session.error.message" );
			$c = $this->storage->get( "hauth_session.error.code"    );

			// clear errors
			$this->storage->deleteMatch( "hauth_session.error." );

			throw new \Hybridauth\Exception( $m, $c );
		}
	}

	// --------------------------------------------------------------------

	/**
	* Try to authenticate the user with a given provider. 
	*
	* If the user is already connected we just return and instance of provider adapter,
	* ELSE, try to authenticate and authorize the user with the provider. 
	*
	* $params is generally an array with required info in order for this provider and HybridAuth to work,
	*  like :
	*          hauth_return_to: URL to call back after authentication is done
	*        openid_identifier: The OpenID identity provider identifier
	*/
	public function authenticate( $providerId, $parameters = array() )
	{
		$adapter = $this->getAdapter( $providerId );

		// if user not connected to $providerId then try setup a new adapter and start the login process for this provider
		if( ! $adapter->isAuthorized() ){
			// clear all $providerId stored data
			$this->storage->deleteMatch( "hauth_session.{$providerId}." );

			# hybridauth base url
			$base_url = $this->config["base_url"];

			$defaults = array(
				'hauth_return_to' => \Hybridauth\Http\Util::getCurrentUrl(),
				'login_start'     => $base_url . ( strpos( $base_url, '?' ) ? '&' : '?' ) . "hauth.start={$providerId}&hauth.time=" . microtime(),
				'login_done'      => $base_url . ( strpos( $base_url, '?' ) ? '&' : '?' ) . "hauth.done={$providerId}",
			);

			$parameters = array_merge( $defaults, (array) $parameters );

			$this->storage->set( "hauth_session.{$providerId}.hauth_return_to"    , $parameters["hauth_return_to"] );
			$this->storage->set( "hauth_session.{$providerId}.hauth_endpoint"     , $parameters["login_done"] ); 
			$this->storage->set( "hauth_session.{$providerId}.id_provider_params" , $parameters );

			// store config to be used by the end point.
			$this->storage->config( "CONFIG", $this->config );

			// move on
			\Hybridauth\Http\Util::redirect( $parameters["login_start"] );
		}

		// else, then return the adapter instance for the given provider
		else{
			return $adapter;
		}
	}

	// --------------------------------------------------------------------

	/**
	* Return the adapter instance for an authenticated provider
	*/ 
	public function getAdapter( $providerId = NULL )
	{
		$adapterFactory = new \Hybridauth\Adapter\AdapterFactory( $this->config, $this->storage );

		return $adapterFactory->setup( $providerId );
	}

	// --------------------------------------------------------------------

	/**
	* Check if the current user is connected to a given provider
	*/
	public function isConnectedWith( $providerId )
	{
		return $this->getAdapter( $providerId )->isAuthorized();
	}

	// --------------------------------------------------------------------

	/**
	* Return array listing all authenticated providers
	*/
	public function getConnectedProviders()
	{
		$idps = array();

		foreach( $this->config["providers"] as $idpid => $params ){
			if( $this->isConnectedWith( $idpid ) ){
				$idps[] = $idpid;
			}
		}

		return $idps;
	}

	// --------------------------------------------------------------------

	/**
	* Return array listing all enabled providers as well as a flag if you are connected.
	*/ 
	public function getEnabledProviders()
	{
		$idps = array();

		foreach( $this->config["providers"] as $idpid => $params ){
			if($params['enabled']) {
				$idps[$idpid] = array( 'connected' => false );

				if( $this->isConnectedWith( $idpid ) ){
					$idps[$idpid]['connected'] = true;
				}
			}
		}

		return $idps;
	}

	// --------------------------------------------------------------------

	/**
	* A generic function to logout all connected provider at once 
	*/ 
	public function logoutAllProviders()
	{
		$idps = $this->getConnectedProviders();

		foreach( $idps as $idp ){
			$adapter = $this->getAdapter( $idp );

			$adapter->logout();
		}
	}

	// --------------------------------------------------------------------

	public static function registerAutoloader()
	{
		spl_autoload_register(__NAMESPACE__ . "\\Hybridauth::autoload");
	}

	// --------------------------------------------------------------------

	public static function autoload($className)
	{
		$thisClass = str_replace(__NAMESPACE__.'\\', '', __CLASS__);

		$baseDir = __DIR__;

		if (substr($baseDir, -strlen($thisClass)) === $thisClass) {
			$baseDir = substr($baseDir, 0, -strlen($thisClass));
		}

		$className = ltrim($className, '\\');
		$fileName  = $baseDir;
		$namespace = '';

		$lastNsPos = strripos($className, '\\');

		if ( $lastNsPos ){
			$namespace = substr($className, 0, $lastNsPos);
			$className = substr($className, $lastNsPos + 1);
			$fileName .= str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR;
		}

		$fileName .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php';

		if (file_exists($fileName)) {
			require $fileName;
		}
	}
}
